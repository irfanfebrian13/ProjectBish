# Copyright (C) 2019 The Raphielscape Company LLC.
#
# Licensed under the Raphielscape Public License, Version 1.c (the "License");
# you may not use this file except in compliance with the License.
#
""" Userbot initialization. """

import os
import heroku3

from requests.exceptions import HTTPError
from sys import version_info
from logging import basicConfig, getLogger, INFO, DEBUG
from distutils.util import strtobool as sb

from telethon import TelegramClient
from telethon.sessions import StringSession

# Bot Logs setup:
CONSOLE_LOGGER_VERBOSE = sb(os.environ.get("CONSOLE_LOGGER_VERBOSE", "False"))

if CONSOLE_LOGGER_VERBOSE:
    basicConfig(
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        level=DEBUG,
    )
else:
    basicConfig(format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
                level=INFO)
LOGS = getLogger(__name__)

if version_info < (3, 8):
    LOGS.info("You MUST have a python version of at least 3.8."
              "Multiple features depend on this. Bot quitting.")
    quit(1)

# Telegram App KEY and HASH
API_KEY = os.environ.get("API_KEY", None)
API_HASH = os.environ.get("API_HASH", None)


# Userbot Session String
STRING_SESSION = os.environ.get("STRING_SESSION", None)

# Logging channel/group ID configuration.
BOTLOG_CHATID = int(os.environ.get("BOTLOG_CHATID", None))

# Userbot logging feature switch.
BOTLOG = sb(os.environ.get("BOTLOG", "False"))
LOGSPAMMER = sb(os.environ.get("LOGSPAMMER", "False"))

# Heroku Credentials for updater.
HEROKU_APP_NAME = os.environ.get("HEROKU_APP_NAME", None)
HEROKU_APP_FALLBACK_NAME = os.environ.get("HEROKU_APP_FALLBACK_NAME", None)
HEROKU_API_KEY = os.environ.get("HEROKU_API_KEY", None)
HEROKU_API_KEY_FALLBACK = os.environ.get("HEROKU_API_KEY_FALLBACK", None)

# Updater
UPSTREAM_REPO_URL = os.environ.get("UPSTREAM_REPO_URL", None)
UPSTREAM_REPO_BRANCH = os.environ.get("UPSTREAM_REPO_BRANCH", None)

# Deploy
MAIN_REPO_BRANCH = os.environ.get("MAIN_REPO_BRANCH", None)


# 'bot' variable
if STRING_SESSION:
    # pylint: disable=invalid-name
    bot = TelegramClient(StringSession(STRING_SESSION), API_KEY, API_HASH)
else:
    # pylint: disable=invalid-name
    bot = TelegramClient("userbot", API_KEY, API_HASH)

#######################################################################
#                        Initialization fallback                      #
heroku = heroku3.from_key(HEROKU_API_KEY)
fallback = None
if HEROKU_API_KEY_FALLBACK and HEROKU_APP_FALLBACK_NAME:
    fallback = heroku3.from_key(HEROKU_API_KEY_FALLBACK)
    try:
        fallback_app = fallback.app(HEROKU_APP_FALLBACK_NAME)
    except HTTPError:
        LOGS.info(
            "Your HEROKU_API_KEY_FALLBACK and HEROKU_APP_FALLBACK_NAME"
            " doesn't seem to be in the same account, or "
            f"{HEROKU_APP_FALLBACK_NAME} not found."
        )
        quit(1)
#######################################################################


async def check_botlog_chatid():
    if not BOTLOG_CHATID and LOGSPAMMER:
        LOGS.info(
            "You must set up the BOTLOG_CHATID variable in the config.env or environment variables, for the private error log storage to work."
        )
        quit(1)

    elif not BOTLOG_CHATID and BOTLOG:
        LOGS.info(
            "You must set up the BOTLOG_CHATID variable in the config.env or environment variables, for the userbot logging feature to work."
        )
        quit(1)

    elif not BOTLOG or not LOGSPAMMER:
        return

    entity = await bot.get_entity(BOTLOG_CHATID)
    if entity.default_banned_rights.send_messages:
        LOGS.info(
            "Your account doesn't have rights to send messages to BOTLOG_CHATID "
            "group. Check if you typed the Chat ID correctly.")
        quit(1)


with bot:
    try:
        bot.loop.run_until_complete(check_botlog_chatid())
    except Exception:
        LOGS.info(
            "BOTLOG_CHATID environment variable isn't a "
            "valid entity. Check your environment variables/config.env file.")
        quit(1)
